
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <title>Applications · HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.3">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    
    <link rel="prev" href="primitives.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="primitives.html">
            
                <a href="primitives.html">
            
                    
                    Primitives
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3" data-path="applications.html">
            
                <a href="applications.html">
            
                    
                    Applications
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Applications</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h3 id="去中心化交易所-dexs">去中心化交易所 (DEXs)</h3>
<p><strong>定义与用途:</strong></p>
<p>用户直接点对点交易加密资产的平台, 无需中心化中介机构（如传统的加密货币交易所）的介入。自动做市商 (Automated Market Makers, AMMs) 是一种特定类型的 DEX，它不依赖传统的订单簿来匹配买卖双方，而是使用流动性池和数学算法来确定资产价格。用户与智能合约控制的流动性池进行交易。主要功能：代币兑换，提供流动性。</p>
<p><strong>具体案例:</strong></p>
<p><strong>案例 1: 在 Uniswap 上进行代币兑换 (Swap)</strong></p>
<ul>
<li><p><strong>功能过程:</strong></p>
<ol>
<li><strong>用户连接钱包:</strong> 用户访问 Uniswap 网站，并连接自己的以太坊钱包（如 MetaMask）。</li>
<li><strong>选择交易对:</strong> 用户选择想要卖出的代币（例如 ETH）和想要买入的代币（例如 DAI）。</li>
<li><strong>输入数量:</strong> 用户输入想要卖出的 ETH 数量或想要买入的 DAI 数量。Uniswap 的 AMM 算法会根据流动性池中两种代币的比例自动计算出另一种代币的数量和当前汇率（价格影响）。</li>
<li><strong>授权与兑换:</strong> 如果是首次交易该代币，用户需要先授权 Uniswap 智能合约访问其钱包中的该代币（这是一个独立的交易，需要支付 Gas 费）。授权后，用户点击“兑换 (Swap)”按钮。</li>
<li><strong>确认交易:</strong> 用户的钱包会弹出交易确认请求，显示预估的 Gas 费。用户确认后，交易被发送到以太坊网络。</li>
<li><strong>交易完成:</strong> 交易在区块链上被确认后，用户钱包中的 ETH 数量减少，DAI 数量增加。</li>
</ol>
</li>
<li><p><strong>所依赖的技术:</strong></p>
<ul>
<li><strong>区块链:</strong> 通常是以太坊 (Ethereum) 区块链，但也扩展到了其他如 Polygon, Arbitrum, Optimism 等 Layer 2 或侧链。</li>
<li><strong>智能合约:</strong> Uniswap 的核心逻辑（如流动性池管理、价格计算、代币兑换）都由智能合约实现。其核心是 <code>x*y=k</code> 的恒定乘积做市商模型（Constant Product Market Maker）。</li>
<li><strong>Web3 钱包:</strong> 如 MetaMask，用于用户与区块链和智能合约进行交互。</li>
</ul>
</li>
<li><p><strong>Input/Output:</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>连接的钱包地址。</li>
<li>要卖出的代币种类和数量 (例如 1 ETH)。</li>
<li>要买入的代币种类 (例如 DAI)。</li>
<li>Gas 费（用于支付交易处理）。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得买入的代币 (例如约 3000 DAI，具体数量取决于当时价格和滑点)。</li>
<li>钱包中卖出代币数量减少。</li>
</ul>
</li>
<li><strong>Input (协议):</strong><ul>
<li>用户提供的代币。</li>
<li>交易请求。</li>
</ul>
</li>
<li><strong>Output (协议):</strong><ul>
<li>将目标代币发送给用户。</li>
<li>更新流动性池中两种代币的储备量。</li>
<li>收取交易手续费，分配给流动性提供者。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>案例 2: 在 Curve Finance 上为稳定币提供流动性</strong></p>
<ul>
<li><p><strong>功能过程:</strong></p>
<ol>
<li><strong>用户连接钱包:</strong> 用户访问 Curve Finance 网站 (curve.fi) 并连接钱包。</li>
<li><strong>选择流动性池:</strong> Curve 专注于稳定币和锚定资产（如封装 BTC）之间的低滑点交易。用户选择一个稳定币池，例如由 DAI, USDC, USDT 组成的 "3pool"。</li>
<li><strong>存入资产:</strong> 用户选择想要存入的一种或多种稳定币，并输入数量。例如，用户可以存入 1000 USDC。</li>
<li><strong>授权与存款:</strong> 用户授权 Curve 智能合约访问其 USDC，然后确认存款交易。</li>
<li><strong>获得 LP 代币:</strong> 存款成功后，用户会收到代表其在流动性池中份额的 LP 代币（例如 3Crv 代币）。</li>
<li><strong>赚取收益:</strong> 用户持有的 LP 代币会持续从该池产生的交易手续费中获得分成。此外，用户还可以将这些 LP 代币质押到 Curve 的 Gauge 系统或其他收益聚合器中以赚取额外的 CRV 代币奖励（流动性挖矿）。</li>
</ol>
</li>
<li><p><strong>所依赖的技术:</strong></p>
<ul>
<li><strong>区块链:</strong> 主要是以太坊，也扩展到其他链。</li>
<li><strong>智能合约:</strong> Curve 使用专门为稳定币优化的 AMM 算法 (Stableswap invariant)，相比 Uniswap 的 <code>x*y=k</code> 模型，可以在锚定资产之间实现更低的滑点。</li>
<li><strong>Vyper 编程语言:</strong> Curve 的许多核心合约使用 Vyper 编写，这是一种以安全性和简洁性为设计目标的 Pythonic 智能合约语言。</li>
</ul>
</li>
<li><p><strong>Input/Output:</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>连接的钱包地址。</li>
<li>要存入的稳定币种类和数量 (例如 1000 USDC)。</li>
<li>Gas 费。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得 LP 代币 (例如 3Crv)。</li>
<li>有权按比例分享流动性池的交易手续费。</li>
<li>可能获得额外的 CRV 代币奖励。</li>
</ul>
</li>
<li><strong>Input (协议):</strong><ul>
<li>用户存入的稳定币。</li>
</ul>
</li>
<li><strong>Output (协议):</strong><ul>
<li>向用户发行 LP 代币。</li>
<li>将用户资金加入流动性池，用于促进交易。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="借贷平台-lending-platforms">借贷平台 (Lending Platforms)</h3>
<p><strong>定义与用途:</strong></p>
<p>去中心化借贷平台允许用户在无需中介的情况下借出或借入加密资产。存款人（贷方）将他们的资产存入平台的流动性池中以赚取利息，而借款人则需要提供超额抵押品来借入资产。利率通常由市场供求关系通过算法动态调整。</p>
<p><strong>主要用途:</strong></p>
<ul>
<li><strong>赚取被动收入:</strong> 用户可以通过存入闲置的加密资产来赚取利息。</li>
<li><strong>获取流动性:</strong> 用户可以在不出售其持有的加密资产（如 ETH、BTC）的情况下，通过抵押这些资产来借入其他资产（如稳定币），用于交易、投资或其他目的。</li>
<li><strong>杠杆交易:</strong> 高级用户可以通过反复存入和借出资产来建立杠杆头寸（风险较高）。</li>
</ul>
<p><strong>具体案例:</strong></p>
<p><strong>案例 1: 在 Aave 上存款赚取利息</strong></p>
<ul>
<li><p><strong>功能过程:</strong></p>
<ol>
<li><strong>用户连接钱包:</strong> 用户访问 Aave 网站 (app.aave.com) 并连接钱包。</li>
<li><strong>选择市场和资产:</strong> Aave 支持多个网络（如以太坊主网、Polygon、Avalanche）。用户选择一个市场，然后浏览可供存款的资产列表及其对应的存款年化收益率 (APY)。</li>
<li><strong>选择存款资产:</strong> 用户选择想要存入的资产，例如 USDC。</li>
<li><strong>输入数量与存款:</strong> 用户输入想要存入的 USDC 数量。如果是首次与 Aave 交互该资产，需要先授权 Aave 智能合约。然后，用户确认存款交易。</li>
<li><strong>获得 aToken:</strong> 存款成功后，用户会收到相应数量的 aToken（例如 aUSDC），这是一种计息代币，代表用户在 Aave 存款池中的份额。aToken 的价值会随着利息的累积而逐渐增加。</li>
<li><strong>赚取利息:</strong> 用户持有的 aToken 会自动累积利息。用户可以随时将 aToken 赎回为原始资产（加上利息）。</li>
</ol>
</li>
<li><p><strong>所依赖的技术:</strong></p>
<ul>
<li><strong>区块链:</strong> 以太坊及其他兼容 EVM 的链。</li>
<li><strong>智能合约:</strong> Aave 的核心功能，包括资金池管理、利率计算模型、借贷逻辑、清算机制等，都由智能合约实现。</li>
<li><strong>利率模型:</strong> 利率根据特定资产的利用率（借出量/总供应量）通过算法动态调整。高利用率会导致更高的存款和借款利率。</li>
<li><strong>aTokens:</strong> ERC-20 标准的计息代币，代表存款人的债权。</li>
</ul>
</li>
<li><p><strong>Input/Output:</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>连接的钱包地址。</li>
<li>要存入的资产种类和数量 (例如 1000 USDC)。</li>
<li>Gas 费。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得相应数量的 aToken (例如 1000 aUSDC)。</li>
<li>开始赚取存款利息，反映在 aToken 数量的增加或其相对于基础资产的价值增加上。</li>
</ul>
</li>
<li><strong>Input (协议):</strong><ul>
<li>用户存入的资产。</li>
</ul>
</li>
<li><strong>Output (协议):</strong><ul>
<li>向用户发行 aToken。</li>
<li>将用户资金加入借贷池，供借款人使用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>案例 2: 在 Compound 上抵押 ETH 借出 DAI</strong></p>
<ul>
<li><p><strong>功能过程:</strong></p>
<ol>
<li><strong>用户连接钱包:</strong> 用户访问 Compound 网站 (app.compound.finance) 并连接钱包。</li>
<li><strong>提供抵押品:</strong> 用户选择想要作为抵押品的资产（例如 ETH），并启用它作为抵押品（这可能需要一笔交易）。然后，用户存入 ETH。</li>
<li><strong>查看借贷能力:</strong> 存入抵押品后，Compound 会根据抵押品的价值和该资产的抵押因子（Collateral Factor，例如 ETH 的抵押因子可能是 80%）计算出用户的最大借贷能力。</li>
<li><strong>选择借出资产:</strong> 用户选择想要借出的资产，例如 DAI。</li>
<li><strong>输入借款数量与借款:</strong> 用户输入想要借入的 DAI 数量（不能超过其借贷能力），然后确认借款交易。</li>
<li><strong>接收借款:</strong> 交易确认后，DAI 会发送到用户的钱包。用户需要为借款支付利息。</li>
<li><strong>监控健康因子:</strong> 用户需要密切关注其账户的健康因子（Health Factor）。如果抵押品价值下降或借款价值上升，导致健康因子低于特定阈值（通常是 1），其抵押品可能会被清算以偿还债务。</li>
</ol>
</li>
<li><p><strong>所依赖的技术:</strong></p>
<ul>
<li><strong>区块链:</strong> 以太坊等。</li>
<li><strong>智能合约:</strong> Compound 的借贷池、利率模型、抵押和清算逻辑由智能合约管理。</li>
<li><strong>cTokens:</strong> 当用户存款时，会收到 cTokens (如 cETH, cDAI)，代表其在池中的份额并赚取利息。当用户借款时，其 cToken 余额不会直接变化，而是产生一笔债务。</li>
<li><strong>抵押因子和清算机制:</strong> 这是风险管理的核心，确保平台的偿付能力。</li>
</ul>
</li>
<li><p><strong>Input/Output:</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>连接的钱包地址。</li>
<li>要抵押的资产种类和数量 (例如 2 ETH)。</li>
<li>要借入的资产种类和数量 (例如 3000 DAI)。</li>
<li>Gas 费。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得借入的资产 (例如 3000 DAI)。</li>
<li>产生一笔需要支付利息的债务。</li>
<li>抵押的资产被锁定在协议中，但仍在赚取存款利息（以 cToken 形式）。</li>
</ul>
</li>
<li><strong>Input (协议):</strong><ul>
<li>用户提供的抵押资产。</li>
<li>用户的借款请求。</li>
</ul>
</li>
<li><strong>Output (协议):</strong><ul>
<li>向用户发放借款资产。</li>
<li>监控用户的抵押率和健康因子。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="稳定币-stablecoins">稳定币 (Stablecoins)</h3>
<p><strong>定义与用途:</strong></p>
<p>稳定币是一种加密货币，其价值与某种相对稳定的资产或一篮子资产锚定。最常见的锚定对象是法定货币，如美元 (USD) 或欧元 (EUR)。稳定币旨在结合加密货币的即时处理、安全性和隐私性，以及法定货币的稳定价值。</p>
<p><strong>主要用途:</strong></p>
<ul>
<li><strong>价值储存:</strong> 在波动的加密市场中提供一个相对稳定的价值储存手段。</li>
<li><strong>交易媒介:</strong> 作为加密货币交易所中常用的报价和交易对，方便用户在不同加密资产之间进行转换，而无需先换回法币。</li>
<li><strong>DeFi 应用的基石:</strong> 广泛用于借贷、衍生品、支付等 DeFi 场景。</li>
<li><strong>跨境支付:</strong> 提供比传统银行系统更快、更便宜的跨境支付方式。</li>
</ul>
<p><strong>具体案例:</strong></p>
<p><strong>案例 1: DAI (去中心化稳定币)</strong></p>
<ul>
<li><strong>定义:</strong> DAI 是由 MakerDAO 协议发行的一种去中心化、抵押品支持的稳定币，其价值锚定美元 (1 DAI ≈ 1 USD)。</li>
<li><p><strong>功能过程 (生成 DAI):</strong></p>
<ol>
<li><strong>用户连接钱包到 Maker Oasis:</strong> 用户访问 MakerDAO 的前端应用 (如 Oasis.app) 并连接钱包。</li>
<li><strong>开设金库 (Vault):</strong> 用户选择一种被 MakerDAO 接受的抵押品类型（如 ETH, WBTC）。</li>
<li><strong>存入抵押品:</strong> 用户将所选抵押品存入金库。例如，存入价值 2000 美元的 ETH。</li>
<li><strong>生成 DAI:</strong> 根据抵押品的类型和当前的最低抵押率要求（例如 ETH 的最低抵押率可能是 150%），用户可以生成一定数量的 DAI。如果用户存入价值 2000 美元的 ETH，并希望保持 200% 的抵押率，他们可以生成最多 1000 DAI。用户输入希望生成的 DAI 数量。</li>
<li><strong>确认交易:</strong> 用户确认交易，DAI 被铸造并发放至用户钱包。用户的金库会记录这笔债务和锁定的抵押品。</li>
<li><strong>偿还与取回:</strong> 用户未来可以通过偿还 DAI 和相应的稳定费（利息）来赎回其抵押品。</li>
</ol>
</li>
<li><p><strong>所依赖的技术:</strong></p>
<ul>
<li><strong>区块链:</strong> 以太坊。</li>
<li><strong>智能合约 (Maker Protocol):</strong> 整个 DAI 的发行、抵押、清算、治理机制都由一系列复杂的智能合约控制。</li>
<li><strong>超额抵押:</strong> DAI 的稳定性依赖于金库中的抵押品价值远超于发行的 DAI 价值。</li>
<li><strong>清算机制:</strong> 如果抵押品的价值下降到危险水平（低于清算线），金库会被清算，抵押品被拍卖以偿还 DAI 债务。</li>
<li><strong>治理代币 (MKR):</strong> MKR 持有者参与协议的治理，包括决定接受哪些抵押品、调整抵押率、稳定费等。</li>
</ul>
</li>
<li><p><strong>Input/Output (生成 DAI):</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>连接的钱包地址。</li>
<li>要存入的抵押品种类和数量 (例如 1 ETH)。</li>
<li>希望生成的 DAI 数量 (例如 1500 DAI，需满足最低抵押率)。</li>
<li>Gas 费。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得生成的 DAI (例如 1500 DAI)。</li>
<li>在 MakerDAO 系统中产生一笔 DAI 债务。</li>
<li>抵押品被锁定在金库中。</li>
</ul>
</li>
<li><strong>Input (协议):</strong><ul>
<li>用户存入的抵押品。</li>
<li>用户生成 DAI 的请求。</li>
</ul>
</li>
<li><strong>Output (协议):</strong><ul>
<li>向用户铸造并发送 DAI。</li>
<li>记录用户的债务和抵押品状态。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>案例 2: USDC (中心化稳定币)</strong></p>
<ul>
<li><strong>定义:</strong> USDC (USD Coin) 是一种由 Centre Consortium (由 Circle 和 Coinbase 创立) 发行的中心化、法定货币抵押的稳定币，其价值与美元 1:1 锚定。</li>
<li><p><strong>功能过程 (获取和使用 USDC):</strong></p>
<ol>
<li><strong>获取 USDC:</strong><ul>
<li><strong>通过中心化交易所:</strong> 用户可以在 Coinbase、Binance 等交易所使用法定货币（如美元）购买 USDC，或者用其他加密货币兑换 USDC。</li>
<li><strong>通过 Circle Account:</strong> 符合条件的机构和个人可以直接通过 Circle 开设账户，存入美元以铸造新的 USDC，或赎回 USDC 换取美元。</li>
</ul>
</li>
<li><strong>在 DeFi 中使用 USDC:</strong> 用户可以将钱包中的 USDC 用于各种 DeFi 应用，如：<ul>
<li>在 Uniswap 等 DEX 上交易其他代币。</li>
<li>在 Aave 或 Compound 等借贷平台上存入 USDC 赚取利息，或抵押其他资产借出 USDC。</li>
<li>向流动性池提供 USDC 作为流动性。</li>
</ul>
</li>
</ol>
</li>
<li><p><strong>所依赖的技术:</strong></p>
<ul>
<li><strong>区块链:</strong> 最初发行在以太坊上 (ERC-20)，现已扩展到多个区块链，如 Solana, Algorand, Tron, Polygon, Avalanche 等。</li>
<li><strong>法定货币储备:</strong> Circle 声称每一枚流通的 USDC 都有等值的美元储备支持，这些储备由受监管的金融机构持有，并定期接受审计。</li>
<li><strong>中心化发行和赎回机制:</strong> 新的 USDC 的铸造和销毁由 Circle 控制。</li>
</ul>
</li>
<li><p><strong>Input/Output (在交易所购买 USDC):</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>法定货币 (例如 1000 USD) 或其他加密货币。</li>
<li>交易所账户。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得相应数量的 USDC (例如 1000 USDC，扣除手续费后)。</li>
</ul>
</li>
<li><strong>Input (发行方 Circle - 铸造过程):</strong><ul>
<li>合作伙伴（如交易所）存入的美元。</li>
</ul>
</li>
<li><strong>Output (发行方 Circle - 铸造过程):</strong><ul>
<li>向合作伙伴的地址铸造等量的 USDC。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="收益聚合器-yield-aggregators">收益聚合器 (Yield Aggregators)</h3>
<p><strong>定义与用途:</strong></p>
<p>收益聚合器 (Yield Aggregators 或 Yield Optimizers) 是一种 DeFi 协议，旨在通过自动化的策略将用户的资金在不同的 DeFi 协议（如借贷平台、DEX 流动性池）中进行投资和再平衡，以最大化用户的收益。它们通常会处理复杂的操作，如收取奖励、将其卖掉换成基础资产并重新投入，从而实现复利效应。</p>
<p><strong>主要用途:</strong></p>
<ul>
<li><strong>自动化收益耕作:</strong> 简化用户参与复杂收益策略的过程。</li>
<li><strong>节省 Gas 费:</strong> 通过将多个用户的交易捆绑在一起执行，可以分摊 Gas 费用。</li>
<li><strong>优化收益:</strong> 运用精心设计的策略，在多个协议间轮换资金，寻找最佳收益机会。</li>
<li><strong>复利效应:</strong> 自动将赚取的奖励再投资，以实现更高的复合回报。</li>
</ul>
<p><strong>具体案例:</strong></p>
<p><strong>案例 1: 使用 Yearn.finance 的 yVaults</strong></p>
<ul>
<li><p><strong>功能过程:</strong></p>
<ol>
<li><strong>用户连接钱包:</strong> 用户访问 Yearn.finance 网站 (yearn.finance) 并连接钱包。</li>
<li><strong>选择 Vault:</strong> Yearn 提供多种 "Vaults" (金库)，每种 Vault 对应一种特定的资产（如 ETH, USDC, DAI, 或其他 LP 代币）和一套收益优化策略。用户选择一个 Vault，例如 "USDC yVault"。</li>
<li><strong>查看策略和风险:</strong> Yearn 会展示该 Vault 使用的策略（例如，将 USDC 存入 Aave 赚取利息，同时将 Aave 的奖励代币收获并再投资）以及相关的风险。</li>
<li><strong>存入资产:</strong> 用户输入想要存入的 USDC 数量。如果是首次交互，需要授权 Yearn 智能合约。然后，用户确认存款交易。</li>
<li><strong>获得 yvToken:</strong> 存款成功后，用户会收到相应数量的 yvToken (例如 yvUSDC)，代表其在该 Vault 中的份额。这些 yvToken 的价值会随着 Vault 策略产生的收益而增加。</li>
<li><strong>自动优化:</strong> Yearn 的智能合约会自动执行策略，例如在不同的借贷平台之间转移资金以获得最高利率，收获奖励代币，将其出售并重新投入到 Vault 中，为用户实现复利。</li>
<li><strong>提取资产:</strong> 用户可以随时将其 yvUSDC 赎回为 USDC（加上累积的收益，扣除协议费用）。</li>
</ol>
</li>
<li><p><strong>所依赖的技术:</strong></p>
<ul>
<li><strong>区块链:</strong> 主要在以太坊上，也扩展到 Fantom 等其他链。</li>
<li><strong>智能合约:</strong> Yearn 的核心是其 Vault 合约和策略合约。Vault 合约负责接收用户存款和处理取款，而策略合约则包含了具体的收益优化逻辑。</li>
<li><strong>策略师 (Strategists):</strong> Yearn 社区的策略师负责设计和实施这些复杂的收益策略。策略需要经过治理投票批准。</li>
<li><strong>Keepers:</strong> 外部机器人或个人，负责定期调用 Vault 合约中的 <code>harvest()</code> 函数，以执行策略、收取奖励和再投资。</li>
</ul>
</li>
<li><p><strong>Input/Output:</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>连接的钱包地址。</li>
<li>要存入的资产种类和数量 (例如 10000 USDC)。</li>
<li>Gas 费。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得相应数量的 yvToken (例如 yvUSDC)。</li>
<li>用户的资金被自动投入到优化策略中，赚取复利收益。yvToken 的价值会随时间增长。</li>
</ul>
</li>
<li><strong>Input (协议 - Vault):</strong><ul>
<li>用户存入的资产。</li>
</ul>
</li>
<li><strong>Output (协议 - Vault):</strong><ul>
<li>向用户发行 yvToken。</li>
<li>根据策略合约的指令管理和调配资金池中的资产。</li>
<li>收取管理费和业绩费，用于协议运营和激励策略师。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="去中心化保险-decentralized-insurance">去中心化保险 (Decentralized Insurance)</h3>
<p><strong>定义与用途:</strong></p>
<p>去中心化保险是利用区块链和智能合约技术提供的保险服务，旨在为 DeFi 用户和协议提供风险保障。与传统保险不同，它通常由社区驱动，索赔处理和资金管理更加透明。</p>
<p><strong>主要用途:</strong></p>
<ul>
<li><strong>智能合约风险保障:</strong> 覆盖由于智能合约代码中的漏洞或 bug 导致的资金损失。</li>
<li><strong>DeFi 协议被黑客攻击保障:</strong> 覆盖因协议遭受黑客攻击而造成的用户资金损失。</li>
<li><strong>稳定币脱锚风险保障:</strong> 在某些情况下，可能提供针对稳定币大幅偏离其锚定价值的风险保障。</li>
<li><strong>托管风险保障:</strong> 针对中心化托管方（如某些桥接协议）的风险。</li>
</ul>
<p><strong>具体案例:</strong></p>
<p><strong>案例 1: 在 Nexus Mutual 购买智能合约风险保障</strong></p>
<ul>
<li><p><strong>功能过程:</strong></p>
<ol>
<li><strong>用户成为会员:</strong> 访问 Nexus Mutual 网站 (nexusmutual.io)。要购买保障或参与风险评估，用户首先需要成为会员。这通常需要通过 KYC/AML（了解你的客户/反洗钱）验证，并购买少量 NXM 代币（Nexus Mutual 的原生代币）并将其质押。</li>
<li><strong>选择保障产品:</strong> 用户浏览可供保障的 DeFi 协议列表（例如 Aave, Uniswap, Compound）。</li>
<li><strong>获取报价:</strong> 用户选择想要保障的协议、保障的金额（例如 10 ETH）以及保障的期限（例如 30 天、90 天、365 天）。系统会根据该协议的风险评估、当前可用的承保能力等因素计算出保费。</li>
<li><strong>购买保障 (Cover):</strong> 如果用户接受报价，他们可以使用 ETH 或 DAI 支付保费。支付成功后，一份代表其保障的 NFT（或记录在智能合约中）将被创建。</li>
<li><strong>提交索赔 (如果发生损失):</strong> 如果在保障期内，受保协议因智能合约漏洞遭受了用户资金损失，用户可以提交索赔申请。</li>
<li><strong>索赔评估与投票:</strong> NXM 代币持有者（风险评估员）会对索赔的有效性进行评估和投票。他们会审查证据，判断损失是否符合保障条款。</li>
<li><strong>赔付:</strong> 如果索赔被批准，Nexus Mutual 的资金池会向用户支付其保障金额。</li>
</ol>
</li>
<li><p><strong>所依赖的技术:</strong></p>
<ul>
<li><strong>区块链:</strong> 以太坊。</li>
<li><strong>智能合约:</strong> Nexus Mutual 的核心逻辑，包括会员管理、保障购买、保费计算、资金池管理、索赔提交和投票系统，都由智能合约实现。</li>
<li><strong>NXM 代币:</strong> 用于治理、风险评估（通过质押 NXM 来评估特定协议的风险并赚取奖励）、索赔评估以及资本化资金池。NXM 的价格由联合曲线 (Bonding Curve) 决定。</li>
<li><strong>社区驱动的风险评估和索赔处理:</strong> 这是去中心化保险的核心特征。</li>
</ul>
</li>
<li><p><strong>Input/Output (购买保障):</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>连接的钱包地址。</li>
<li>KYC 信息 (成为会员时)。</li>
<li>用于购买和质押 NXM 的资金。</li>
<li>选择的保障协议、保障金额、保障期限。</li>
<li>用于支付保费的 ETH 或 DAI。</li>
<li>Gas 费。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得一份保障凭证 (通常是 NFT 或智能合约记录)。</li>
<li>在保障期内，如果发生符合条件的损失，有权提交索赔。</li>
</ul>
</li>
<li><strong>Input (协议):</strong><ul>
<li>用户的保费。</li>
<li>风险评估员质押的 NXM。</li>
</ul>
</li>
<li><strong>Output (协议):</strong><ul>
<li>向用户发出保障。</li>
<li>管理共同资金池，用于潜在的赔付。</li>
<li>在发生有效索赔时进行赔付。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="合成资产和衍生品-synthetic-assets-and-derivatives">合成资产和衍生品 (Synthetic Assets and Derivatives)</h3>
<p><strong>定义与用途:</strong></p>
<p><strong>合成资产 (Synthetic Assets)</strong> 是在区块链上创建的代币，它们模拟并追踪另一种基础资产（可以是加密货币、法定货币、股票、商品、指数等）的价值。用户无需实际持有基础资产即可获得其价格敞口。</p>
<p><strong>去中心化衍生品 (Decentralized Derivatives)</strong> 是在区块链上交易的金融合约，其价值来源于一种或多种基础资产。常见的衍生品包括期货、期权和永续合约。</p>
<p><strong>主要用途:</strong></p>
<ul>
<li><strong>访问传统资产:</strong> 允许加密用户接触传统金融市场中的资产，如美股 (AAPL, TSLA)、黄金 (XAU) 等，而无需通过传统券商。</li>
<li><strong>对冲风险:</strong> 交易者可以使用衍生品来对冲其在其他资产上的头寸风险。</li>
<li><strong>杠杆交易:</strong> 衍生品（尤其是期货和永续合约）通常允许用户进行杠杆交易，放大潜在收益（也放大潜在亏损）。</li>
<li><strong>创造新的交易机会:</strong> 可以创建针对各种独特指标或事件的衍生品。</li>
<li><strong>提高资本效率:</strong> 合成资产可以解锁原本流动性不足的资产的价值。</li>
</ul>
<p><strong>具体案例:</strong></p>
<p><strong>案例 1: 在 Synthetix 上铸造和交易合成美元 (sUSD) 和合成苹果股票 (sAAPL)</strong></p>
<ul>
<li><p><strong>功能过程 (铸造 sUSD):</strong></p>
<ol>
<li><strong>用户连接钱包并获取 SNX:</strong> 用户访问 Synthetix 的前端应用 (如 Kwenta 或 Synthetix.io 上的质押应用) 并连接钱包。要铸造合成资产 (Synths)，用户首先需要持有并质押 Synthetix 的原生代币 SNX。</li>
<li><strong>质押 SNX:</strong> 用户选择质押其 SNX 代币。Synthetix 协议要求超额抵押，例如，用户可能需要质押价值 500 美元的 SNX 才能铸造 100 美元的 sUSD（这意味着抵押率是 500%）。</li>
<li><strong>铸造 sUSD:</strong> 用户根据其质押的 SNX 数量和当前的抵押率 (C-Ratio) 要求，铸造 sUSD (一种锚定美元的合成稳定币)。这会在协议中产生一笔以 sUSD 计价的债务。</li>
<li><strong>管理债务和抵押率:</strong> 用户需要监控其抵押率。如果 SNX 价格下跌，导致抵押率低于目标水平，用户可能需要补充 SNX 抵押或销毁部分 sUSD 来避免被清算。</li>
</ol>
</li>
<li><p><strong>功能过程 (用 sUSD 交易 sAAPL):</strong></p>
<ol>
<li><strong>访问 Kwenta (一个基于 Synthetix 的衍生品交易平台):</strong> 用户使用其钱包中的 sUSD。</li>
<li><strong>选择交易对:</strong> 用户选择 sUSD/sAAPL 交易对。</li>
<li><strong>执行交易:</strong> 用户可以用 sUSD 购买 sAAPL，或者卖出 sAAPL 换回 sUSD。Synthetix 使用一种独特的 "点对池" (peer-to-contract) 交易模型。当用户交易时，他们实际上是在与整个 SNX 质押者构成的债务池进行交易。价格由预言机 (Oracle) 提供。</li>
<li><strong>持有或进一步交易:</strong> 用户持有的 sAAPL 的价值会随着苹果公司真实股票价格的变动而变动（由预言机喂价）。</li>
</ol>
</li>
<li><p><strong>所依赖的技术:</strong></p>
<ul>
<li><strong>区块链:</strong> 主要是以太坊和 Optimism (一个 Layer 2 解决方案，用于降低交易费用和延迟)。</li>
<li><strong>智能合约:</strong> Synthetix 协议的核心，包括 SNX 质押、Synths 的铸造和销毁、债务管理、交易执行以及与预言机的交互。</li>
<li><strong>SNX 代币:</strong> 作为抵押品来铸造合成资产，并用于协议治理。SNX 质押者会从协议产生的交易费中获得奖励。</li>
<li><strong>预言机 (Oracles):</strong> 如 Chainlink，用于向区块链提供现实世界资产（如股票、商品价格）的实时价格数据，这是合成资产定价的关键。</li>
<li><strong>债务池模型:</strong> 所有 SNX 质押者的债务被汇总到一个共享的债务池中。当一个合成资产的价格上涨时，整个债务池的价值也会相应增加，反之亦然。</li>
</ul>
</li>
<li><p><strong>Input/Output (铸造 sUSD):</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>连接的钱包地址。</li>
<li>要质押的 SNX 数量。</li>
<li>Gas 费。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得铸造的 sUSD。</li>
<li>在 Synthetix 协议中产生一笔以 sUSD 计价的债务。</li>
</ul>
</li>
<li><strong>Input (协议):</strong><ul>
<li>用户质押的 SNX。</li>
</ul>
</li>
<li><strong>Output (协议):</strong><ul>
<li>向用户发行 sUSD。</li>
<li>更新用户的债务和整个协议的债务池。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Input/Output (用 sUSD 购买 sAAPL):</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>钱包中的 sUSD 数量。</li>
<li>想要购买的 sAAPL 数量（或等值的 sUSD）。</li>
<li>Gas 费 (在 Optimism 上较低)。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得 sAAPL 代币。</li>
<li>钱包中 sUSD 数量减少。</li>
</ul>
</li>
<li><strong>Input (协议):</strong><ul>
<li>用户的 sUSD。</li>
<li>交易指令。</li>
</ul>
</li>
<li><strong>Output (协议):</strong><ul>
<li>根据预言机价格，销毁用户的 sUSD 并向其发行等值的 sAAPL。</li>
<li>更新全局债务池中不同合成资产的构成。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="流动性挖矿-liquidity-mining">流动性挖矿 (Liquidity Mining)</h3>
<p><strong>定义与用途:</strong></p>
<p>流动性挖矿是一种 DeFi 机制，用户通过向 DeFi 协议（通常是 DEX 的流动性池或借贷平台）提供加密资产作为流动性，从而获得该协议原生代币的额外奖励。这是一种激励用户为协议提供早期流动性、促进协议增长和去中心化治理的方式。</p>
<p><strong>主要用途:</strong></p>
<ul>
<li><strong>引导流动性:</strong> 帮助新协议或新市场快速积累所需的流动性，使其能够正常运作。</li>
<li><strong>激励用户参与:</strong> 吸引用户使用协议并成为其早期支持者。</li>
<li><strong>分发治理代币:</strong> 将协议的治理权（通过代币）分发给实际使用和支持协议的用户。</li>
<li><strong>提高资本回报:</strong> 流动性提供者除了能赚取交易手续费或存款利息外，还能获得额外的代币奖励，从而提高整体收益率。</li>
</ul>
<p><strong>具体案例:</strong></p>
<p><strong>案例 1: 在 Sushiswap 上为 ETH/USDT 池提供流动性并参与流动性挖矿</strong></p>
<ul>
<li><p><strong>功能过程:</strong></p>
<ol>
<li><strong>用户连接钱包:</strong> 用户访问 Sushiswap 网站 (app.sushi.com) 并连接钱包。</li>
<li><strong>导航到流动性池:</strong> 用户找到 "Pool" 或 "Liquidity" 部分。</li>
<li><strong>选择交易对并提供流动性:</strong> 用户选择一个有流动性挖矿奖励的池，例如 ETH/USDT。他们需要按当前市场价格比例同时提供这两种代币。例如，如果 1 ETH = 3000 USDT，用户想提供 1 ETH 的流动性，就需要同时提供 1 ETH 和 3000 USDT。</li>
<li><strong>授权与添加流动性:</strong> 用户授权 Sushiswap 智能合约访问其 ETH 和 USDT，然后确认添加流动性的交易。</li>
<li><strong>获得 SLP 代币:</strong> 成功添加流动性后，用户会收到 Sushiswap LP (SLP) 代币，代表其在该流动性池中的份额。</li>
<li><strong>质押 SLP 代币进行挖矿:</strong><ul>
<li>用户导航到 Sushiswap 的 "Farm" 或 "Yield" 部分。</li>
<li>找到对应的 ETH/USDT SLP 农场 (Farm)。</li>
<li>用户质押 (Stake) 他们收到的 ETH/USDT SLP 代币。</li>
</ul>
</li>
<li><strong>赚取 SUSHI 奖励:</strong> 一旦 SLP 代币被质押到农场中，用户就开始根据其质押份额和该农场的奖励率赚取 SUSHI 代币（Sushiswap 的原生治理代币）。用户通常可以随时领取 (Harvest/Claim) 这些 SUSHI 奖励。</li>
<li><strong>解除质押与移除流动性:</strong> 用户可以随时解除质押其 SLP 代币，然后到流动性池中移除其 ETH 和 USDT（可能会有无常损失）。</li>
</ol>
</li>
<li><p><strong>所依赖的技术:</strong></p>
<ul>
<li><strong>区块链:</strong> 以太坊及其他多条链。</li>
<li><strong>智能合约:</strong><ul>
<li><strong>AMM 合约:</strong> 管理流动性池和交易 (Sushiswap 是 Uniswap V2 的一个分叉，最初使用类似的 AMM 模型)。</li>
<li><strong>LP 代币合约:</strong> 创建和管理 SLP 代币。</li>
<li><strong>MasterChef 合约 (或类似变体):</strong> 这是流动性挖矿的核心合约，负责管理用户质押的 LP 代币，并根据预设的分配规则向他们分发奖励代币 (SUSHI)。</li>
</ul>
</li>
<li><strong>SUSHI 代币:</strong> 作为奖励分发给流动性提供者，并用于协议治理。</li>
</ul>
</li>
<li><p><strong>Input/Output (提供流动性并质押挖矿):</strong></p>
<ul>
<li><strong>Input (用户):</strong><ul>
<li>连接的钱包地址。</li>
<li>两种代币以特定比例存入 (例如 1 ETH 和 3000 USDT)。</li>
<li>Gas 费 (用于授权、添加流动性、质押 SLP)。</li>
</ul>
</li>
<li><strong>Output (用户):</strong><ul>
<li>获得 SLP 代币。</li>
<li>通过质押 SLP 代币，持续赚取 SUSHI 代币奖励。</li>
<li>仍然从其在流动性池中的份额中赚取交易手续费分成。</li>
<li>面临无常损失的风险。</li>
</ul>
</li>
<li><strong>Input (协议 - MasterChef 合约):</strong><ul>
<li>用户质押的 SLP 代币。</li>
</ul>
</li>
<li><strong>Output (协议 - MasterChef 合约):</strong><ul>
<li>根据用户的质押份额和时间，向用户账户累积 SUSHI 奖励。</li>
<li>允许用户领取累积的 SUSHI。</li>
</ul>
</li>
</ul>
</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="primitives.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Primitives">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Applications","level":"1.3","depth":1,"previous":{"title":"Primitives","level":"1.2","depth":1,"path":"primitives.md","ref":"primitives.md","articles":[]},"dir":"ltr"},"config":{"gitbook":"*","theme":"default","variables":{},"plugins":[],"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"applications.md","mtime":"2025-05-19T15:16:36.854Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-19T15:37:55.673Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

