
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <title>Primitives Â· HonKit</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 6.0.3">
        
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="applications.html" />
    
    
    <link rel="prev" href="./" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    Hi!
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.2" data-path="primitives.html">
            
                <a href="primitives.html">
            
                    
                    Primitives
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" data-path="applications.html">
            
                <a href="applications.html">
            
                    
                    DApp Scenarios
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="tokenization.html">
            
                <a href="tokenization.html">
            
                    
                    Tokenization
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.5" data-path="techniques.html">
            
                <a href="techniques.html">
            
                    
                    Technical Details
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.6" data-path="BISinnohub.html">
            
                <a href="BISinnohub.html">
            
                    
                    BISIH projects matrix
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            Published with HonKit
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >Primitives</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h3 id="decentralized-finance-defi-blockchain-technology-blockchain-distributed-ledger-bitcoin-btc-and-ethereum-eth">Decentralized Finance (DeFi), Blockchain Technology (Blockchain), Distributed Ledger, Bitcoin (BTC), and Ethereum (ETH)</h3>
<ul>
<li>DeFi: A series of decentralized financial services based on smart contracts on Ethereum. Each service or product corresponds to an implementation of a smart contract. Application scenarios include: Loanable Funds Markets, Decentralized Exchanges (DEX), Stablecoins, Derivatives, etc.</li>
<li>Blockchain: Essentially a database technology, a distributed ledger. Distributed means that multiple nodes form a network, and all nodes keep an identical copy of the ledger. Each block contains a series of transaction data, a timestamp, and a cryptographic hash of the previous block (a key to trace back to the previous block). When a new block is generated, it is added to the end of the chain, and the copy on each node is updated accordingly, forming a transaction record that is difficult to tamper with. The blockchains of Bitcoin and Ethereum are public chains (everyone can see the data). There are also other blockchain platforms as well as some private chains and consortium chains.</li>
<li>Bitcoin: The first successful decentralized cryptocurrency based on blockchain technology. Satoshi Nakamoto released the Bitcoin genesis block on January 3, 2009.</li>
<li>Ethereum: A blockchain platform, analogous to a community, characterized by the introduction of the concept of Smart Contracts, allowing developers to build decentralized applications (DApps) on it to achieve more complex functions. Proposed by Vitalik Buterin in 2013. On this platform, things like ERC-20 tokens, Non-Fungible Tokens (NFTs), Decentralized Autonomous Organizations (DAOs), etc., can be implemented.</li>
<li>Distributed Ledger: This is the broadest category. Besides blockchain implementations, there are other implementation methods, such as DAGs (Directed Acyclic Graphs, e.g., IOTA's Tangle or Hedera Hashgraph).</li>
</ul>
<blockquote>
<p>Summary:
(Underlying Technology) Blockchain technology is a foundational technology.</p>
<p>(First Layer: Blockchain Platforms) Bitcoin and Ethereum are specific implementations and platforms based on blockchain technology, each having its own protocol defining its operation.</p>
<p>(Second Layer: Application Layer) Decentralized Finance (DeFi) is a series of financial applications built on blockchain platforms like Ethereum, and these applications also follow specific protocols.</p>
<p>Two meanings of decentralization:</p>
<ol>
<li>Infrastructure Architecture: The network is decentralized; each node is connected to other nodes, rather than a centralized node.</li>
<li>Application of Smart Contracts: There is no need for a centralized intermediary to execute contract terms; all transactions are automatically executed on the blockchain.</li>
</ol>
</blockquote>
<h3 id="why-are-smart-contracts-smart-and-what-is-a-protocol">Why are Smart Contracts "Smart", and What is a Protocol?</h3>
<ul>
<li>A smart contract refers to self-executing code deployed on a blockchain that automatically executes the terms of the contract when preset conditions are met. "Smart" mainly refers to "automated execution" without human intervention. It's analogous to a vending machine: one party selects a product, inserts money, and the transaction is completed automatically.</li>
<li>Protocols permeate all layers of blockchain technology. Essentially, they are community-recognized norms, much like language is a human protocol where people follow the same grammar and semantics to communicate. At the base layer of blockchain technology, there are network protocols and consensus protocols. (i) Each platform has its own protocols, such as the Bitcoin protocol and the Ethereum protocol. These protocols define the consensus algorithm (e.g., Bitcoin chose PoW, Ethereum initially used PoW and later switched to PoS), block reward rules (how many new native tokens are rewarded to miners/validators when a new block is generated, and whether this reward changes over time, like Bitcoin's halving mechanism), new token generation mechanisms (native tokens like BTC, ETH are mainly generated through block rewards; the protocol specifies their initial supply, if any, and subsequent issuance rate), transaction fee models (how user-paid transaction fees are distributed), difficulty adjustment algorithms ((Nonce difficulty in PoW): the protocol includes an algorithm that automatically adjusts mining difficulty based on the network's total hash rate (or block generation rate) to maintain a relatively stable block time), and block structure and size limits, etc. These initial settings are all encoded in the first version of the client software of the protocol. Subsequent major changes usually require a hard fork and widespread acceptance and upgrades by network participants. (ii) At the application layer, there are also a series of DeFi protocols, such as lending protocols (which define interest rates, liquidation thresholds, etc.), the ERC-20 protocol (which defines functions that token contracts must implement, such as <code>transfer()</code> and <code>balanceOf()</code>, so that different tokens can interact with wallets, exchanges, and other smart contracts in a unified way), Uniswap's liquidity pool automated market maker protocol, etc.</li>
</ul>
<blockquote>
<p>Summary:
Protocols are sets of rules; smart contracts are the means of implementing those rules.</p>
</blockquote>
<h3 id="the-lifecycle-of-a-transaction">The Lifecycle of a Transaction</h3>
<ul>
<li>There're two types of accounts: <ul>
<li>wallets owned by users are called EOA (Externally Owned Account), which include a pair of keys: secret key - public key - the account's public address (e.g., Ethereum addresses start with <code>0x</code>). The address is public and used to receive funds and identify the account. </li>
<li>There is another type of account called a Contract Account, which are instances of smart contracts, such as Uniswap's trading pair contract or an ERC-20 token contract. These are controlled by smart contract code and also have an address. </li>
<li>Only EOAs can initiate transactions; contract accounts cannot actively initiate transactions but can only respond to calls from EOAs. Transactions that EOAs can initiate include: transferring funds (sending a certain amount of native tokens to another EOA address), calling functions of a contract account (e.g., swapping tokens on a DEX, minting NFTs, participating in lending, etc.).</li>
</ul>
</li>
<li>Transaction lifecycle: <ul>
<li>(i) A user signs a transaction using their private key and sends the transaction request to a node on the connected blockchain network via wallet software like MetaMask or their own running node software (e.g., Geth). The node performs initial checks on the transaction format, signature, account balance, etc. </li>
<li>(ii) If it passes, the transaction is placed in this node's mempool and propagated to other nodes in the network via the Gossip protocol. </li>
<li>(iii) Operators of various nodes (miners or validators) compete for the right to add the next block. They select a batch of transactions (usually those willing to pay higher transaction fees) from the mempool to package into a new block. This node will execute the code required to complete the transaction (such as calling a smart contract) in its local Ethereum Virtual Machine (EVM) or similar environment. During execution, the state of the contract may change (e.g., variable values updated, events emitted, transfers to other addresses). The miner/validator executing the transaction will include the execution results (new state root hash, transaction receipts, etc.) in the proposed block and broadcast this block to other nodes in the network. </li>
<li>(iv) Other full nodes, upon receiving the new block, will independently re-execute all transactions in the block (including smart contract calls) to verify their validity and results.</li>
</ul>
</li>
<li>During the execution of a transaction, there are some computations, such as calling a smart contract function or transferring funds. These computations are executed in the Ethereum Virtual Machine (EVM). Each underlying opcode in the EVM, such as addition (ADD), storing data to the blockchain (SSTORE), reading data from storage (SLOAD), etc., has a predefined Gas cost. These costs are paid by the transaction initiator to the miners/validators.</li>
<li>If a transaction fails (state reverts, as if it never happened), the Gas already consumed (up to the point where the limit was exceeded) will still be paid to the miners/validators.</li>
</ul>
<blockquote>
<p>Summary:
Wallet initiates transaction request -&gt; Node receives request and broadcasts -&gt; Miner/Validator selects and packages -&gt; Other nodes verify the block, transaction is added to the chain.</p>
<p>The cost is paid by the transaction initiator (sender) to the miner/validator.</p>
</blockquote>
<h3 id="nodes-and-network-miners-and-validators">Nodes and Network, Miners and Validators</h3>
<ul>
<li>Nodes are individual computers or servers running specific blockchain client software (e.g., Bitcoin Core, Ethereum's Geth or Nethermind). They communicate directly with other nodes via the internet, sharing and synchronizing blockchain data, thus forming the blockchain network. Their functions include: storing a copy of the blockchain, validating transactions and blocks, and propagating information to other nodes.</li>
<li>Nodes where miners or validators reside are special nodes that produce blocks. Miners and validators correspond to PoW (Proof-of-Work) and PoS (Proof-of-Stake) consensus mechanisms, respectively. Bitcoin uses PoW consensus; Ethereum uses PoS consensus. Mining refers to miners attempting to find a value called a "nonce." When this nonce is hashed with other data in the block, the resulting hash must be less than a specific target value (this target value is dynamically adjusted based on network hash rate to ensure a block is generated approximately every fixed interval, e.g., about 10 minutes for Bitcoin, about 15 seconds for early Ethereum). The first miner to successfully mine a block receives a certain amount of newly issued native tokens (block reward) and all transaction fees within that block. Validators are nodes or individuals/organizations that gain the qualification to participate in creating and validating new blocks by staking a certain amount of the blockchain's native tokens. The system selects a validator to propose the next new block according to some algorithm (usually related to factors like the amount of tokens staked by the validator, staking duration, etc.). Other validators then vote on the proposed block. In a PoW system, any individual or organization with sufficient computing power (usually specialized ASIC miners or GPUs) and running the corresponding mining software can become a miner. In a PoS system, any individual or organization with a sufficient amount of native tokens to stake and running the corresponding validator client software can become a validator. In Ethereum PoS, as of early 2024, the number of active validators exceeded 900,000.</li>
</ul>
<h3 id="tokens">Tokens</h3>
<ul>
<li>Tokens are divided into two types: Native Tokens and tokens created via smart contracts. Native tokens like BTC and ETH are part of the blockchain protocol. For example, BTC is stipulated to be generated through mining, has a fixed cap (21 million), and its production is periodically halved. ETH: Initially mined via PoW, now generated through PoS staking rewards; its issuance policy can be adjusted through community consensus. They are stored directly in accounts (addresses) on the corresponding blockchain. Users control these native tokens on their addresses by controlling their private keys.</li>
<li>Another category is application-layer tokens. These are tokens created on a blockchain platform (like Ethereum) via smart contracts. Their total supply, inflation mechanisms, burning mechanisms, etc., are set by the creator of the token contract. ERC-20 is the standard protocol for Fungible Tokens, and ERC-721 is the standard protocol for Non-Fungible Tokens (NFTs). A standard protocol is like a socket interface; it specifies the functions that a token contract must implement. This facilitates interaction between different tokens, wallets, smart contracts, and exchanges. For example, when a user adds a new ERC-20 Token, the wallet knows it can use <code>balanceOf()</code> to query the balance of this Token and <code>transfer()</code> to initiate a transfer. Fungible Tokens mean that every unit of such a token is identical and interchangeable, including stablecoins (like USDC, DAI), and governance tokens (like Uniswap's UNI, holders can use them to vote on the future development of the protocol; each similar governance token has the same voting power). Non-Fungible Tokens are unique, indivisible, and irreplaceable. Each NFT has its unique attributes and identifiers. Examples include digital art, in-game items, virtual real estate, etc. The ownership and transaction history of NFTs are stored on the blockchain. Example: A smart contract for a stablecoin like USDC. When its issuer (e.g., Circle) receives an equivalent amount of USD reserves, they can call the minting function of the USDC contract through a privileged address they control, generating the corresponding amount of USDC tokens on-chain and sending them to a specified address. An NFT project party, after the user pays the minting fee, its smart contract will call the minting function to create a new, unique NFT for the user (assigning a new token ID and recording the user as the owner).</li>
</ul>
<h3 id="digital-currencies-can-also-be-traded-on-cexs">Digital Currencies Can Also Be Traded on CEXs</h3>
<ul>
<li>For most ordinary users, centralized exchanges (CEXs) are the primary venues for buying, selling, and trading digital currencies. Some well-known examples of centralized exchanges include:<ul>
<li>Binance: Currently one of the world's largest cryptocurrency exchanges by trading volume.</li>
<li>Coinbase: A well-known exchange listed in the United States, particularly popular among US users.</li>
<li>Kraken: Another long-standing and reputable exchange offering a variety of cryptocurrency trades.</li>
<li>Huobi Global: An exchange with significant influence in the Asian market.
Apart from deposits and withdrawals, transactions between users and the exchange are conducted via off-chain internal transactions on the CEX's internal ledger.</li>
</ul>
</li>
<li>Deposits: When users want to trade on a CEX, they first need to send their digital currency (e.g., Bitcoin, Ethereum, or a specific ERC-20 token) from their personal wallet (which is an address on the respective blockchain) to a specific deposit address generated by the CEX for that user. This deposit address is a blockchain address controlled by the CEX. This transfer from the user's personal wallet to the CEX's deposit address is a real on-chain transaction, and it will be recorded on the corresponding distributed ledger (e.g., Bitcoin blockchain or Ethereum blockchain). The CEX's system monitors its deposit addresses. Upon detecting a successful on-chain deposit, the CEX will credit the corresponding amount to the user's account in its internal, centralized database (or internal ledger). Withdrawals are the reverse process.</li>
<li>Trading on a CEX: Once a user's funds are confirmed in the CEX's internal ledger, the user can then trade on the platform (e.g., buying ETH with BTC). These trades occurring within the CEX platform, in most cases, do not immediately generate new transaction records on the blockchain. Instead, the CEX simply updates the balances of different users in its internal centralized database. For example, if User A sells 1 BTC to User B, the CEX's database will decrease User A's BTC balance by 1 and increase User B's BTC balance by 1. This off-chain processing method makes transactions very fast (almost instant) and transaction fees are usually lower (or are fixed platform fees charged by the CEX) because they do not directly consume blockchain network Gas fees or miner fees.</li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="./" class="navigation navigation-prev " aria-label="Previous page: Hi!">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="applications.html" class="navigation navigation-next " aria-label="Next page: DApp Scenarios">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"Primitives","level":"1.2","depth":1,"next":{"title":"DApp Scenarios","level":"1.3","depth":1,"path":"applications.md","ref":"applications.md","articles":[]},"previous":{"title":"Hi!","level":"1.1","depth":1,"path":"README.md","ref":"README.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"language":"en","gitbook":"*"},"file":{"path":"primitives.md","mtime":"2025-05-21T14:16:00.898Z","type":"markdown"},"gitbook":{"version":"6.0.3","time":"2025-05-22T15:08:23.391Z"},"basePath":".","book":{"language":"en"}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/@honkit/honkit-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

